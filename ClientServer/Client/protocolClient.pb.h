// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: protocolClient.proto
// Protobuf C++ Version: 5.29.0-dev

#ifndef GOOGLE_PROTOBUF_INCLUDED_protocolClient_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_protocolClient_2eproto_2epb_2eh
#define PROTOBUF_USE_DLLS

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_protocolClient_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_protocolClient_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_protocolClient_2eproto;
class CapturePiece;
struct CapturePieceDefaultTypeInternal;
extern CapturePieceDefaultTypeInternal _CapturePiece_default_instance_;
class Command;
struct CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class GetError;
struct GetErrorDefaultTypeInternal;
extern GetErrorDefaultTypeInternal _GetError_default_instance_;
class GetProxyPlayer;
struct GetProxyPlayerDefaultTypeInternal;
extern GetProxyPlayerDefaultTypeInternal _GetProxyPlayer_default_instance_;
class GetState;
struct GetStateDefaultTypeInternal;
extern GetStateDefaultTypeInternal _GetState_default_instance_;
class GetTime;
struct GetTimeDefaultTypeInternal;
extern GetTimeDefaultTypeInternal _GetTime_default_instance_;
class GetWinner;
struct GetWinnerDefaultTypeInternal;
extern GetWinnerDefaultTypeInternal _GetWinner_default_instance_;
class IntPair;
struct IntPairDefaultTypeInternal;
extern IntPairDefaultTypeInternal _IntPair_default_instance_;
class MovePiece;
struct MovePieceDefaultTypeInternal;
extern MovePieceDefaultTypeInternal _MovePiece_default_instance_;
class PlacePiece;
struct PlacePieceDefaultTypeInternal;
extern PlacePieceDefaultTypeInternal _PlacePiece_default_instance_;
class SetStrategy;
struct SetStrategyDefaultTypeInternal;
extern SetStrategyDefaultTypeInternal _SetStrategy_default_instance_;
class UndoAction;
struct UndoActionDefaultTypeInternal;
extern UndoActionDefaultTypeInternal _UndoAction_default_instance_;
class WhereToMovePiece;
struct WhereToMovePieceDefaultTypeInternal;
extern WhereToMovePieceDefaultTypeInternal _WhereToMovePiece_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

enum Ecommand : int {
  NoCommand = 0,
  Place = 1,
  Move = 2,
  Capture = 3,
  WhereToMove = 4,
  WhereToCapture = 5,
  Reset = 6,
  Undo = 7,
  ProxyPlayer = 8,
  Time = 9,
  StartGame = 10,
  Strategy = 11,
  Win = 12,
  OpponentDisconnect = 13,
  ServerDisconnect = 14,
  StartLobby = 15,
  GameAlreadyExists = 16,
  Error = 17,
  State = 18,
  Ecommand_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Ecommand_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Ecommand_IsValid(int value);
extern const uint32_t Ecommand_internal_data_[];
constexpr Ecommand Ecommand_MIN = static_cast<Ecommand>(0);
constexpr Ecommand Ecommand_MAX = static_cast<Ecommand>(18);
constexpr int Ecommand_ARRAYSIZE = 18 + 1;
const ::google::protobuf::EnumDescriptor*
Ecommand_descriptor();
template <typename T>
const std::string& Ecommand_Name(T value) {
  static_assert(std::is_same<T, Ecommand>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Ecommand_Name().");
  return Ecommand_Name(static_cast<Ecommand>(value));
}
template <>
inline const std::string& Ecommand_Name(Ecommand value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Ecommand_descriptor,
                                                 0, 18>(
      static_cast<int>(value));
}
inline bool Ecommand_Parse(absl::string_view name, Ecommand* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Ecommand>(
      Ecommand_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SetStrategy final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SetStrategy) */ {
 public:
  inline SetStrategy() : SetStrategy(nullptr) {}
  ~SetStrategy() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetStrategy(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetStrategy(const SetStrategy& from) : SetStrategy(nullptr, from) {}
  inline SetStrategy(SetStrategy&& from) noexcept
      : SetStrategy(nullptr, std::move(from)) {}
  inline SetStrategy& operator=(const SetStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetStrategy& operator=(SetStrategy&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetStrategy& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetStrategy* internal_default_instance() {
    return reinterpret_cast<const SetStrategy*>(
        &_SetStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(SetStrategy& a, SetStrategy& b) { a.Swap(&b); }
  inline void Swap(SetStrategy* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetStrategy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetStrategy* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SetStrategy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetStrategy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetStrategy& from) { SetStrategy::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SetStrategy* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SetStrategy"; }

 protected:
  explicit SetStrategy(::google::protobuf::Arena* arena);
  SetStrategy(::google::protobuf::Arena* arena, const SetStrategy& from);
  SetStrategy(::google::protobuf::Arena* arena, SetStrategy&& from) noexcept
      : SetStrategy(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
  };
  // int32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SetStrategy)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SetStrategy_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetStrategy& from_msg);
    ::int32_t x_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocolClient_2eproto;
};
// -------------------------------------------------------------------

class PlacePiece final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:PlacePiece) */ {
 public:
  inline PlacePiece() : PlacePiece(nullptr) {}
  ~PlacePiece() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlacePiece(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlacePiece(const PlacePiece& from) : PlacePiece(nullptr, from) {}
  inline PlacePiece(PlacePiece&& from) noexcept
      : PlacePiece(nullptr, std::move(from)) {}
  inline PlacePiece& operator=(const PlacePiece& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlacePiece& operator=(PlacePiece&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlacePiece& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlacePiece* internal_default_instance() {
    return reinterpret_cast<const PlacePiece*>(
        &_PlacePiece_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(PlacePiece& a, PlacePiece& b) { a.Swap(&b); }
  inline void Swap(PlacePiece* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlacePiece* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlacePiece* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<PlacePiece>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlacePiece& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlacePiece& from) { PlacePiece::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlacePiece* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "PlacePiece"; }

 protected:
  explicit PlacePiece(::google::protobuf::Arena* arena);
  PlacePiece(::google::protobuf::Arena* arena, const PlacePiece& from);
  PlacePiece(::google::protobuf::Arena* arena, PlacePiece&& from) noexcept
      : PlacePiece(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kPlayerFieldNumber = 3,
  };
  // int32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // int32 y = 2;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // int32 player = 3;
  void clear_player() ;
  ::int32_t player() const;
  void set_player(::int32_t value);

  private:
  ::int32_t _internal_player() const;
  void _internal_set_player(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:PlacePiece)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PlacePiece_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PlacePiece& from_msg);
    ::int32_t x_;
    ::int32_t y_;
    ::int32_t player_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocolClient_2eproto;
};
// -------------------------------------------------------------------

class MovePiece final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MovePiece) */ {
 public:
  inline MovePiece() : MovePiece(nullptr) {}
  ~MovePiece() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MovePiece(
      ::google::protobuf::internal::ConstantInitialized);

  inline MovePiece(const MovePiece& from) : MovePiece(nullptr, from) {}
  inline MovePiece(MovePiece&& from) noexcept
      : MovePiece(nullptr, std::move(from)) {}
  inline MovePiece& operator=(const MovePiece& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovePiece& operator=(MovePiece&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MovePiece& default_instance() {
    return *internal_default_instance();
  }
  static inline const MovePiece* internal_default_instance() {
    return reinterpret_cast<const MovePiece*>(
        &_MovePiece_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(MovePiece& a, MovePiece& b) { a.Swap(&b); }
  inline void Swap(MovePiece* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovePiece* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MovePiece* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MovePiece>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MovePiece& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MovePiece& from) { MovePiece::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MovePiece* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "MovePiece"; }

 protected:
  explicit MovePiece(::google::protobuf::Arena* arena);
  MovePiece(::google::protobuf::Arena* arena, const MovePiece& from);
  MovePiece(::google::protobuf::Arena* arena, MovePiece&& from) noexcept
      : MovePiece(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFromXFieldNumber = 1,
    kFromYFieldNumber = 2,
    kToXFieldNumber = 3,
    kToYFieldNumber = 4,
    kPlayerFieldNumber = 5,
  };
  // int32 from_x = 1;
  void clear_from_x() ;
  ::int32_t from_x() const;
  void set_from_x(::int32_t value);

  private:
  ::int32_t _internal_from_x() const;
  void _internal_set_from_x(::int32_t value);

  public:
  // int32 from_y = 2;
  void clear_from_y() ;
  ::int32_t from_y() const;
  void set_from_y(::int32_t value);

  private:
  ::int32_t _internal_from_y() const;
  void _internal_set_from_y(::int32_t value);

  public:
  // int32 to_x = 3;
  void clear_to_x() ;
  ::int32_t to_x() const;
  void set_to_x(::int32_t value);

  private:
  ::int32_t _internal_to_x() const;
  void _internal_set_to_x(::int32_t value);

  public:
  // int32 to_y = 4;
  void clear_to_y() ;
  ::int32_t to_y() const;
  void set_to_y(::int32_t value);

  private:
  ::int32_t _internal_to_y() const;
  void _internal_set_to_y(::int32_t value);

  public:
  // int32 player = 5;
  void clear_player() ;
  ::int32_t player() const;
  void set_player(::int32_t value);

  private:
  ::int32_t _internal_player() const;
  void _internal_set_player(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MovePiece)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MovePiece_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MovePiece& from_msg);
    ::int32_t from_x_;
    ::int32_t from_y_;
    ::int32_t to_x_;
    ::int32_t to_y_;
    ::int32_t player_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocolClient_2eproto;
};
// -------------------------------------------------------------------

class IntPair final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:IntPair) */ {
 public:
  inline IntPair() : IntPair(nullptr) {}
  ~IntPair() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IntPair(
      ::google::protobuf::internal::ConstantInitialized);

  inline IntPair(const IntPair& from) : IntPair(nullptr, from) {}
  inline IntPair(IntPair&& from) noexcept
      : IntPair(nullptr, std::move(from)) {}
  inline IntPair& operator=(const IntPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntPair& operator=(IntPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntPair* internal_default_instance() {
    return reinterpret_cast<const IntPair*>(
        &_IntPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(IntPair& a, IntPair& b) { a.Swap(&b); }
  inline void Swap(IntPair* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntPair* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntPair* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<IntPair>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IntPair& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IntPair& from) { IntPair::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IntPair* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "IntPair"; }

 protected:
  explicit IntPair(::google::protobuf::Arena* arena);
  IntPair(::google::protobuf::Arena* arena, const IntPair& from);
  IntPair(::google::protobuf::Arena* arena, IntPair&& from) noexcept
      : IntPair(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFirstFieldNumber = 1,
    kSecondFieldNumber = 2,
  };
  // int32 first = 1;
  void clear_first() ;
  ::int32_t first() const;
  void set_first(::int32_t value);

  private:
  ::int32_t _internal_first() const;
  void _internal_set_first(::int32_t value);

  public:
  // int32 second = 2;
  void clear_second() ;
  ::int32_t second() const;
  void set_second(::int32_t value);

  private:
  ::int32_t _internal_second() const;
  void _internal_set_second(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:IntPair)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_IntPair_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const IntPair& from_msg);
    ::int32_t first_;
    ::int32_t second_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocolClient_2eproto;
};
// -------------------------------------------------------------------

class GetWinner final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GetWinner) */ {
 public:
  inline GetWinner() : GetWinner(nullptr) {}
  ~GetWinner() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetWinner(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetWinner(const GetWinner& from) : GetWinner(nullptr, from) {}
  inline GetWinner(GetWinner&& from) noexcept
      : GetWinner(nullptr, std::move(from)) {}
  inline GetWinner& operator=(const GetWinner& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWinner& operator=(GetWinner&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWinner& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWinner* internal_default_instance() {
    return reinterpret_cast<const GetWinner*>(
        &_GetWinner_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(GetWinner& a, GetWinner& b) { a.Swap(&b); }
  inline void Swap(GetWinner* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWinner* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWinner* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetWinner>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetWinner& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetWinner& from) { GetWinner::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetWinner* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GetWinner"; }

 protected:
  explicit GetWinner(::google::protobuf::Arena* arena);
  GetWinner(::google::protobuf::Arena* arena, const GetWinner& from);
  GetWinner(::google::protobuf::Arena* arena, GetWinner&& from) noexcept
      : GetWinner(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStateFieldNumber = 1,
  };
  // int32 state = 1;
  void clear_state() ;
  ::int32_t state() const;
  void set_state(::int32_t value);

  private:
  ::int32_t _internal_state() const;
  void _internal_set_state(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GetWinner)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetWinner_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetWinner& from_msg);
    ::int32_t state_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocolClient_2eproto;
};
// -------------------------------------------------------------------

class GetTime final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GetTime) */ {
 public:
  inline GetTime() : GetTime(nullptr) {}
  ~GetTime() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetTime(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetTime(const GetTime& from) : GetTime(nullptr, from) {}
  inline GetTime(GetTime&& from) noexcept
      : GetTime(nullptr, std::move(from)) {}
  inline GetTime& operator=(const GetTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTime& operator=(GetTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTime* internal_default_instance() {
    return reinterpret_cast<const GetTime*>(
        &_GetTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(GetTime& a, GetTime& b) { a.Swap(&b); }
  inline void Swap(GetTime* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTime* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTime* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetTime>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTime& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetTime& from) { GetTime::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetTime* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GetTime"; }

 protected:
  explicit GetTime(::google::protobuf::Arena* arena);
  GetTime(::google::protobuf::Arena* arena, const GetTime& from);
  GetTime(::google::protobuf::Arena* arena, GetTime&& from) noexcept
      : GetTime(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimePlayer1FieldNumber = 1,
    kTimePlayer2FieldNumber = 2,
    kTimeActionFieldNumber = 3,
  };
  // int32 timePlayer1 = 1;
  void clear_timeplayer1() ;
  ::int32_t timeplayer1() const;
  void set_timeplayer1(::int32_t value);

  private:
  ::int32_t _internal_timeplayer1() const;
  void _internal_set_timeplayer1(::int32_t value);

  public:
  // int32 timePlayer2 = 2;
  void clear_timeplayer2() ;
  ::int32_t timeplayer2() const;
  void set_timeplayer2(::int32_t value);

  private:
  ::int32_t _internal_timeplayer2() const;
  void _internal_set_timeplayer2(::int32_t value);

  public:
  // int32 timeAction = 3;
  void clear_timeaction() ;
  ::int32_t timeaction() const;
  void set_timeaction(::int32_t value);

  private:
  ::int32_t _internal_timeaction() const;
  void _internal_set_timeaction(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GetTime)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetTime_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetTime& from_msg);
    ::int32_t timeplayer1_;
    ::int32_t timeplayer2_;
    ::int32_t timeaction_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocolClient_2eproto;
};
// -------------------------------------------------------------------

class GetState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GetState) */ {
 public:
  inline GetState() : GetState(nullptr) {}
  ~GetState() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetState(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetState(const GetState& from) : GetState(nullptr, from) {}
  inline GetState(GetState&& from) noexcept
      : GetState(nullptr, std::move(from)) {}
  inline GetState& operator=(const GetState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetState& operator=(GetState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetState& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetState* internal_default_instance() {
    return reinterpret_cast<const GetState*>(
        &_GetState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(GetState& a, GetState& b) { a.Swap(&b); }
  inline void Swap(GetState* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetState* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetState& from) { GetState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetState* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GetState"; }

 protected:
  explicit GetState(::google::protobuf::Arena* arena);
  GetState(::google::protobuf::Arena* arena, const GetState& from);
  GetState(::google::protobuf::Arena* arena, GetState&& from) noexcept
      : GetState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStateFieldNumber = 1,
    kPlayerFieldNumber = 2,
  };
  // int32 state = 1;
  void clear_state() ;
  ::int32_t state() const;
  void set_state(::int32_t value);

  private:
  ::int32_t _internal_state() const;
  void _internal_set_state(::int32_t value);

  public:
  // int32 player = 2;
  void clear_player() ;
  ::int32_t player() const;
  void set_player(::int32_t value);

  private:
  ::int32_t _internal_player() const;
  void _internal_set_player(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GetState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetState_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetState& from_msg);
    ::int32_t state_;
    ::int32_t player_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocolClient_2eproto;
};
// -------------------------------------------------------------------

class GetProxyPlayer final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GetProxyPlayer) */ {
 public:
  inline GetProxyPlayer() : GetProxyPlayer(nullptr) {}
  ~GetProxyPlayer() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetProxyPlayer(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetProxyPlayer(const GetProxyPlayer& from) : GetProxyPlayer(nullptr, from) {}
  inline GetProxyPlayer(GetProxyPlayer&& from) noexcept
      : GetProxyPlayer(nullptr, std::move(from)) {}
  inline GetProxyPlayer& operator=(const GetProxyPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProxyPlayer& operator=(GetProxyPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProxyPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProxyPlayer* internal_default_instance() {
    return reinterpret_cast<const GetProxyPlayer*>(
        &_GetProxyPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(GetProxyPlayer& a, GetProxyPlayer& b) { a.Swap(&b); }
  inline void Swap(GetProxyPlayer* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProxyPlayer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProxyPlayer* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetProxyPlayer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetProxyPlayer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetProxyPlayer& from) { GetProxyPlayer::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetProxyPlayer* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GetProxyPlayer"; }

 protected:
  explicit GetProxyPlayer(::google::protobuf::Arena* arena);
  GetProxyPlayer(::google::protobuf::Arena* arena, const GetProxyPlayer& from);
  GetProxyPlayer(::google::protobuf::Arena* arena, GetProxyPlayer&& from) noexcept
      : GetProxyPlayer(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerFieldNumber = 1,
  };
  // int32 player = 1;
  void clear_player() ;
  ::int32_t player() const;
  void set_player(::int32_t value);

  private:
  ::int32_t _internal_player() const;
  void _internal_set_player(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GetProxyPlayer)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetProxyPlayer_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetProxyPlayer& from_msg);
    ::int32_t player_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocolClient_2eproto;
};
// -------------------------------------------------------------------

class GetError final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GetError) */ {
 public:
  inline GetError() : GetError(nullptr) {}
  ~GetError() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetError(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetError(const GetError& from) : GetError(nullptr, from) {}
  inline GetError(GetError&& from) noexcept
      : GetError(nullptr, std::move(from)) {}
  inline GetError& operator=(const GetError& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetError& operator=(GetError&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetError& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetError* internal_default_instance() {
    return reinterpret_cast<const GetError*>(
        &_GetError_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(GetError& a, GetError& b) { a.Swap(&b); }
  inline void Swap(GetError* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetError* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetError* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GetError>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetError& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetError& from) { GetError::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetError* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GetError"; }

 protected:
  explicit GetError(::google::protobuf::Arena* arena);
  GetError(::google::protobuf::Arena* arena, const GetError& from);
  GetError(::google::protobuf::Arena* arena, GetError&& from) noexcept
      : GetError(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 1,
  };
  // int32 error = 1;
  void clear_error() ;
  ::int32_t error() const;
  void set_error(::int32_t value);

  private:
  ::int32_t _internal_error() const;
  void _internal_set_error(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GetError)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GetError_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetError& from_msg);
    ::int32_t error_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocolClient_2eproto;
};
// -------------------------------------------------------------------

class CapturePiece final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CapturePiece) */ {
 public:
  inline CapturePiece() : CapturePiece(nullptr) {}
  ~CapturePiece() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CapturePiece(
      ::google::protobuf::internal::ConstantInitialized);

  inline CapturePiece(const CapturePiece& from) : CapturePiece(nullptr, from) {}
  inline CapturePiece(CapturePiece&& from) noexcept
      : CapturePiece(nullptr, std::move(from)) {}
  inline CapturePiece& operator=(const CapturePiece& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapturePiece& operator=(CapturePiece&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapturePiece& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapturePiece* internal_default_instance() {
    return reinterpret_cast<const CapturePiece*>(
        &_CapturePiece_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(CapturePiece& a, CapturePiece& b) { a.Swap(&b); }
  inline void Swap(CapturePiece* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapturePiece* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapturePiece* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<CapturePiece>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapturePiece& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CapturePiece& from) { CapturePiece::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CapturePiece* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CapturePiece"; }

 protected:
  explicit CapturePiece(::google::protobuf::Arena* arena);
  CapturePiece(::google::protobuf::Arena* arena, const CapturePiece& from);
  CapturePiece(::google::protobuf::Arena* arena, CapturePiece&& from) noexcept
      : CapturePiece(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // int32 y = 2;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:CapturePiece)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CapturePiece_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CapturePiece& from_msg);
    ::int32_t x_;
    ::int32_t y_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocolClient_2eproto;
};
// -------------------------------------------------------------------

class WhereToMovePiece final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:WhereToMovePiece) */ {
 public:
  inline WhereToMovePiece() : WhereToMovePiece(nullptr) {}
  ~WhereToMovePiece() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WhereToMovePiece(
      ::google::protobuf::internal::ConstantInitialized);

  inline WhereToMovePiece(const WhereToMovePiece& from) : WhereToMovePiece(nullptr, from) {}
  inline WhereToMovePiece(WhereToMovePiece&& from) noexcept
      : WhereToMovePiece(nullptr, std::move(from)) {}
  inline WhereToMovePiece& operator=(const WhereToMovePiece& from) {
    CopyFrom(from);
    return *this;
  }
  inline WhereToMovePiece& operator=(WhereToMovePiece&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WhereToMovePiece& default_instance() {
    return *internal_default_instance();
  }
  static inline const WhereToMovePiece* internal_default_instance() {
    return reinterpret_cast<const WhereToMovePiece*>(
        &_WhereToMovePiece_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(WhereToMovePiece& a, WhereToMovePiece& b) { a.Swap(&b); }
  inline void Swap(WhereToMovePiece* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WhereToMovePiece* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WhereToMovePiece* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<WhereToMovePiece>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WhereToMovePiece& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WhereToMovePiece& from) { WhereToMovePiece::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WhereToMovePiece* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "WhereToMovePiece"; }

 protected:
  explicit WhereToMovePiece(::google::protobuf::Arena* arena);
  WhereToMovePiece(::google::protobuf::Arena* arena, const WhereToMovePiece& from);
  WhereToMovePiece(::google::protobuf::Arena* arena, WhereToMovePiece&& from) noexcept
      : WhereToMovePiece(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPairsFieldNumber = 3,
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // repeated .IntPair pairs = 3;
  int pairs_size() const;
  private:
  int _internal_pairs_size() const;

  public:
  void clear_pairs() ;
  ::IntPair* mutable_pairs(int index);
  ::google::protobuf::RepeatedPtrField<::IntPair>* mutable_pairs();

  private:
  const ::google::protobuf::RepeatedPtrField<::IntPair>& _internal_pairs() const;
  ::google::protobuf::RepeatedPtrField<::IntPair>* _internal_mutable_pairs();
  public:
  const ::IntPair& pairs(int index) const;
  ::IntPair* add_pairs();
  const ::google::protobuf::RepeatedPtrField<::IntPair>& pairs() const;
  // int32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // int32 y = 2;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:WhereToMovePiece)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_WhereToMovePiece_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WhereToMovePiece& from_msg);
    ::google::protobuf::RepeatedPtrField< ::IntPair > pairs_;
    ::int32_t x_;
    ::int32_t y_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocolClient_2eproto;
};
// -------------------------------------------------------------------

class UndoAction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:UndoAction) */ {
 public:
  inline UndoAction() : UndoAction(nullptr) {}
  ~UndoAction() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UndoAction(
      ::google::protobuf::internal::ConstantInitialized);

  inline UndoAction(const UndoAction& from) : UndoAction(nullptr, from) {}
  inline UndoAction(UndoAction&& from) noexcept
      : UndoAction(nullptr, std::move(from)) {}
  inline UndoAction& operator=(const UndoAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline UndoAction& operator=(UndoAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UndoAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const UndoAction* internal_default_instance() {
    return reinterpret_cast<const UndoAction*>(
        &_UndoAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(UndoAction& a, UndoAction& b) { a.Swap(&b); }
  inline void Swap(UndoAction* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UndoAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UndoAction* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<UndoAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UndoAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UndoAction& from) { UndoAction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UndoAction* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "UndoAction"; }

 protected:
  explicit UndoAction(::google::protobuf::Arena* arena);
  UndoAction(::google::protobuf::Arena* arena, const UndoAction& from);
  UndoAction(::google::protobuf::Arena* arena, UndoAction&& from) noexcept
      : UndoAction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPositionFieldNumber = 3,
    kStateFieldNumber = 1,
    kPlayerFieldNumber = 2,
  };
  // repeated .IntPair position = 3;
  int position_size() const;
  private:
  int _internal_position_size() const;

  public:
  void clear_position() ;
  ::IntPair* mutable_position(int index);
  ::google::protobuf::RepeatedPtrField<::IntPair>* mutable_position();

  private:
  const ::google::protobuf::RepeatedPtrField<::IntPair>& _internal_position() const;
  ::google::protobuf::RepeatedPtrField<::IntPair>* _internal_mutable_position();
  public:
  const ::IntPair& position(int index) const;
  ::IntPair* add_position();
  const ::google::protobuf::RepeatedPtrField<::IntPair>& position() const;
  // int32 state = 1;
  void clear_state() ;
  ::int32_t state() const;
  void set_state(::int32_t value);

  private:
  ::int32_t _internal_state() const;
  void _internal_set_state(::int32_t value);

  public:
  // int32 player = 2;
  void clear_player() ;
  ::int32_t player() const;
  void set_player(::int32_t value);

  private:
  ::int32_t _internal_player() const;
  void _internal_set_player(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:UndoAction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UndoAction_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UndoAction& from_msg);
    ::google::protobuf::RepeatedPtrField< ::IntPair > position_;
    ::int32_t state_;
    ::int32_t player_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocolClient_2eproto;
};
// -------------------------------------------------------------------

class Command final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Command) */ {
 public:
  inline Command() : Command(nullptr) {}
  ~Command() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Command(
      ::google::protobuf::internal::ConstantInitialized);

  inline Command(const Command& from) : Command(nullptr, from) {}
  inline Command(Command&& from) noexcept
      : Command(nullptr, std::move(from)) {}
  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Command& operator=(Command&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Command& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kMove = 2,
    kPlace = 3,
    kCapture = 4,
    kWhereToMovePiece = 5,
    kSetStrategy = 6,
    kGetTime = 7,
    kGetproxyPlayer = 8,
    kUndoAction = 9,
    kGetState = 10,
    kGetWinner = 11,
    kGetError = 12,
    PAYLOAD_NOT_SET = 0,
  };
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
        &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Command& a, Command& b) { a.Swap(&b); }
  inline void Swap(Command* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Command* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Command* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Command>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Command& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Command& from) { Command::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Command* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "Command"; }

 protected:
  explicit Command(::google::protobuf::Arena* arena);
  Command(::google::protobuf::Arena* arena, const Command& from);
  Command(::google::protobuf::Arena* arena, Command&& from) noexcept
      : Command(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommandFieldNumber = 1,
    kMoveFieldNumber = 2,
    kPlaceFieldNumber = 3,
    kCaptureFieldNumber = 4,
    kWhereToMovePieceFieldNumber = 5,
    kSetStrategyFieldNumber = 6,
    kGetTimeFieldNumber = 7,
    kGetproxyPlayerFieldNumber = 8,
    kUndoActionFieldNumber = 9,
    kGetStateFieldNumber = 10,
    kGetWinnerFieldNumber = 11,
    kGetErrorFieldNumber = 12,
  };
  // .Ecommand command = 1;
  void clear_command() ;
  ::Ecommand command() const;
  void set_command(::Ecommand value);

  private:
  ::Ecommand _internal_command() const;
  void _internal_set_command(::Ecommand value);

  public:
  // .MovePiece move = 2;
  bool has_move() const;
  private:
  bool _internal_has_move() const;

  public:
  void clear_move() ;
  const ::MovePiece& move() const;
  PROTOBUF_NODISCARD ::MovePiece* release_move();
  ::MovePiece* mutable_move();
  void set_allocated_move(::MovePiece* value);
  void unsafe_arena_set_allocated_move(::MovePiece* value);
  ::MovePiece* unsafe_arena_release_move();

  private:
  const ::MovePiece& _internal_move() const;
  ::MovePiece* _internal_mutable_move();

  public:
  // .PlacePiece place = 3;
  bool has_place() const;
  private:
  bool _internal_has_place() const;

  public:
  void clear_place() ;
  const ::PlacePiece& place() const;
  PROTOBUF_NODISCARD ::PlacePiece* release_place();
  ::PlacePiece* mutable_place();
  void set_allocated_place(::PlacePiece* value);
  void unsafe_arena_set_allocated_place(::PlacePiece* value);
  ::PlacePiece* unsafe_arena_release_place();

  private:
  const ::PlacePiece& _internal_place() const;
  ::PlacePiece* _internal_mutable_place();

  public:
  // .CapturePiece capture = 4;
  bool has_capture() const;
  private:
  bool _internal_has_capture() const;

  public:
  void clear_capture() ;
  const ::CapturePiece& capture() const;
  PROTOBUF_NODISCARD ::CapturePiece* release_capture();
  ::CapturePiece* mutable_capture();
  void set_allocated_capture(::CapturePiece* value);
  void unsafe_arena_set_allocated_capture(::CapturePiece* value);
  ::CapturePiece* unsafe_arena_release_capture();

  private:
  const ::CapturePiece& _internal_capture() const;
  ::CapturePiece* _internal_mutable_capture();

  public:
  // .WhereToMovePiece whereToMovePiece = 5;
  bool has_wheretomovepiece() const;
  private:
  bool _internal_has_wheretomovepiece() const;

  public:
  void clear_wheretomovepiece() ;
  const ::WhereToMovePiece& wheretomovepiece() const;
  PROTOBUF_NODISCARD ::WhereToMovePiece* release_wheretomovepiece();
  ::WhereToMovePiece* mutable_wheretomovepiece();
  void set_allocated_wheretomovepiece(::WhereToMovePiece* value);
  void unsafe_arena_set_allocated_wheretomovepiece(::WhereToMovePiece* value);
  ::WhereToMovePiece* unsafe_arena_release_wheretomovepiece();

  private:
  const ::WhereToMovePiece& _internal_wheretomovepiece() const;
  ::WhereToMovePiece* _internal_mutable_wheretomovepiece();

  public:
  // .SetStrategy setStrategy = 6;
  bool has_setstrategy() const;
  private:
  bool _internal_has_setstrategy() const;

  public:
  void clear_setstrategy() ;
  const ::SetStrategy& setstrategy() const;
  PROTOBUF_NODISCARD ::SetStrategy* release_setstrategy();
  ::SetStrategy* mutable_setstrategy();
  void set_allocated_setstrategy(::SetStrategy* value);
  void unsafe_arena_set_allocated_setstrategy(::SetStrategy* value);
  ::SetStrategy* unsafe_arena_release_setstrategy();

  private:
  const ::SetStrategy& _internal_setstrategy() const;
  ::SetStrategy* _internal_mutable_setstrategy();

  public:
  // .GetTime getTime = 7;
  bool has_gettime() const;
  private:
  bool _internal_has_gettime() const;

  public:
  void clear_gettime() ;
  const ::GetTime& gettime() const;
  PROTOBUF_NODISCARD ::GetTime* release_gettime();
  ::GetTime* mutable_gettime();
  void set_allocated_gettime(::GetTime* value);
  void unsafe_arena_set_allocated_gettime(::GetTime* value);
  ::GetTime* unsafe_arena_release_gettime();

  private:
  const ::GetTime& _internal_gettime() const;
  ::GetTime* _internal_mutable_gettime();

  public:
  // .GetProxyPlayer getproxyPlayer = 8;
  bool has_getproxyplayer() const;
  private:
  bool _internal_has_getproxyplayer() const;

  public:
  void clear_getproxyplayer() ;
  const ::GetProxyPlayer& getproxyplayer() const;
  PROTOBUF_NODISCARD ::GetProxyPlayer* release_getproxyplayer();
  ::GetProxyPlayer* mutable_getproxyplayer();
  void set_allocated_getproxyplayer(::GetProxyPlayer* value);
  void unsafe_arena_set_allocated_getproxyplayer(::GetProxyPlayer* value);
  ::GetProxyPlayer* unsafe_arena_release_getproxyplayer();

  private:
  const ::GetProxyPlayer& _internal_getproxyplayer() const;
  ::GetProxyPlayer* _internal_mutable_getproxyplayer();

  public:
  // .UndoAction undoAction = 9;
  bool has_undoaction() const;
  private:
  bool _internal_has_undoaction() const;

  public:
  void clear_undoaction() ;
  const ::UndoAction& undoaction() const;
  PROTOBUF_NODISCARD ::UndoAction* release_undoaction();
  ::UndoAction* mutable_undoaction();
  void set_allocated_undoaction(::UndoAction* value);
  void unsafe_arena_set_allocated_undoaction(::UndoAction* value);
  ::UndoAction* unsafe_arena_release_undoaction();

  private:
  const ::UndoAction& _internal_undoaction() const;
  ::UndoAction* _internal_mutable_undoaction();

  public:
  // .GetState getState = 10;
  bool has_getstate() const;
  private:
  bool _internal_has_getstate() const;

  public:
  void clear_getstate() ;
  const ::GetState& getstate() const;
  PROTOBUF_NODISCARD ::GetState* release_getstate();
  ::GetState* mutable_getstate();
  void set_allocated_getstate(::GetState* value);
  void unsafe_arena_set_allocated_getstate(::GetState* value);
  ::GetState* unsafe_arena_release_getstate();

  private:
  const ::GetState& _internal_getstate() const;
  ::GetState* _internal_mutable_getstate();

  public:
  // .GetWinner getWinner = 11;
  bool has_getwinner() const;
  private:
  bool _internal_has_getwinner() const;

  public:
  void clear_getwinner() ;
  const ::GetWinner& getwinner() const;
  PROTOBUF_NODISCARD ::GetWinner* release_getwinner();
  ::GetWinner* mutable_getwinner();
  void set_allocated_getwinner(::GetWinner* value);
  void unsafe_arena_set_allocated_getwinner(::GetWinner* value);
  ::GetWinner* unsafe_arena_release_getwinner();

  private:
  const ::GetWinner& _internal_getwinner() const;
  ::GetWinner* _internal_mutable_getwinner();

  public:
  // .GetError getError = 12;
  bool has_geterror() const;
  private:
  bool _internal_has_geterror() const;

  public:
  void clear_geterror() ;
  const ::GetError& geterror() const;
  PROTOBUF_NODISCARD ::GetError* release_geterror();
  ::GetError* mutable_geterror();
  void set_allocated_geterror(::GetError* value);
  void unsafe_arena_set_allocated_geterror(::GetError* value);
  ::GetError* unsafe_arena_release_geterror();

  private:
  const ::GetError& _internal_geterror() const;
  ::GetError* _internal_mutable_geterror();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:Command)
 private:
  class _Internal;
  void set_has_move();
  void set_has_place();
  void set_has_capture();
  void set_has_wheretomovepiece();
  void set_has_setstrategy();
  void set_has_gettime();
  void set_has_getproxyplayer();
  void set_has_undoaction();
  void set_has_getstate();
  void set_has_getwinner();
  void set_has_geterror();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 12, 11,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Command_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Command& from_msg);
    int command_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::MovePiece* move_;
      ::PlacePiece* place_;
      ::CapturePiece* capture_;
      ::WhereToMovePiece* wheretomovepiece_;
      ::SetStrategy* setstrategy_;
      ::GetTime* gettime_;
      ::GetProxyPlayer* getproxyplayer_;
      ::UndoAction* undoaction_;
      ::GetState* getstate_;
      ::GetWinner* getwinner_;
      ::GetError* geterror_;
    } payload_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protocolClient_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Command

// .Ecommand command = 1;
inline void Command::clear_command() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.command_ = 0;
}
inline ::Ecommand Command::command() const {
  // @@protoc_insertion_point(field_get:Command.command)
  return _internal_command();
}
inline void Command::set_command(::Ecommand value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:Command.command)
}
inline ::Ecommand Command::_internal_command() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::Ecommand>(_impl_.command_);
}
inline void Command::_internal_set_command(::Ecommand value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.command_ = value;
}

// .MovePiece move = 2;
inline bool Command::has_move() const {
  return payload_case() == kMove;
}
inline bool Command::_internal_has_move() const {
  return payload_case() == kMove;
}
inline void Command::set_has_move() {
  _impl_._oneof_case_[0] = kMove;
}
inline void Command::clear_move() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kMove) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.move_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.move_);
    }
    clear_has_payload();
  }
}
inline ::MovePiece* Command::release_move() {
  // @@protoc_insertion_point(field_release:Command.move)
  if (payload_case() == kMove) {
    clear_has_payload();
    auto* temp = _impl_.payload_.move_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MovePiece& Command::_internal_move() const {
  return payload_case() == kMove ? *_impl_.payload_.move_ : reinterpret_cast<::MovePiece&>(::_MovePiece_default_instance_);
}
inline const ::MovePiece& Command::move() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Command.move)
  return _internal_move();
}
inline ::MovePiece* Command::unsafe_arena_release_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Command.move)
  if (payload_case() == kMove) {
    clear_has_payload();
    auto* temp = _impl_.payload_.move_;
    _impl_.payload_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_move(::MovePiece* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_move();
    _impl_.payload_.move_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.move)
}
inline ::MovePiece* Command::_internal_mutable_move() {
  if (payload_case() != kMove) {
    clear_payload();
    set_has_move();
    _impl_.payload_.move_ =
        ::google::protobuf::Message::DefaultConstruct<::MovePiece>(GetArena());
  }
  return _impl_.payload_.move_;
}
inline ::MovePiece* Command::mutable_move() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::MovePiece* _msg = _internal_mutable_move();
  // @@protoc_insertion_point(field_mutable:Command.move)
  return _msg;
}

// .PlacePiece place = 3;
inline bool Command::has_place() const {
  return payload_case() == kPlace;
}
inline bool Command::_internal_has_place() const {
  return payload_case() == kPlace;
}
inline void Command::set_has_place() {
  _impl_._oneof_case_[0] = kPlace;
}
inline void Command::clear_place() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kPlace) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.place_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.place_);
    }
    clear_has_payload();
  }
}
inline ::PlacePiece* Command::release_place() {
  // @@protoc_insertion_point(field_release:Command.place)
  if (payload_case() == kPlace) {
    clear_has_payload();
    auto* temp = _impl_.payload_.place_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.place_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PlacePiece& Command::_internal_place() const {
  return payload_case() == kPlace ? *_impl_.payload_.place_ : reinterpret_cast<::PlacePiece&>(::_PlacePiece_default_instance_);
}
inline const ::PlacePiece& Command::place() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Command.place)
  return _internal_place();
}
inline ::PlacePiece* Command::unsafe_arena_release_place() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Command.place)
  if (payload_case() == kPlace) {
    clear_has_payload();
    auto* temp = _impl_.payload_.place_;
    _impl_.payload_.place_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_place(::PlacePiece* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_place();
    _impl_.payload_.place_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.place)
}
inline ::PlacePiece* Command::_internal_mutable_place() {
  if (payload_case() != kPlace) {
    clear_payload();
    set_has_place();
    _impl_.payload_.place_ =
        ::google::protobuf::Message::DefaultConstruct<::PlacePiece>(GetArena());
  }
  return _impl_.payload_.place_;
}
inline ::PlacePiece* Command::mutable_place() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::PlacePiece* _msg = _internal_mutable_place();
  // @@protoc_insertion_point(field_mutable:Command.place)
  return _msg;
}

// .CapturePiece capture = 4;
inline bool Command::has_capture() const {
  return payload_case() == kCapture;
}
inline bool Command::_internal_has_capture() const {
  return payload_case() == kCapture;
}
inline void Command::set_has_capture() {
  _impl_._oneof_case_[0] = kCapture;
}
inline void Command::clear_capture() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kCapture) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.capture_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.capture_);
    }
    clear_has_payload();
  }
}
inline ::CapturePiece* Command::release_capture() {
  // @@protoc_insertion_point(field_release:Command.capture)
  if (payload_case() == kCapture) {
    clear_has_payload();
    auto* temp = _impl_.payload_.capture_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.capture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CapturePiece& Command::_internal_capture() const {
  return payload_case() == kCapture ? *_impl_.payload_.capture_ : reinterpret_cast<::CapturePiece&>(::_CapturePiece_default_instance_);
}
inline const ::CapturePiece& Command::capture() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Command.capture)
  return _internal_capture();
}
inline ::CapturePiece* Command::unsafe_arena_release_capture() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Command.capture)
  if (payload_case() == kCapture) {
    clear_has_payload();
    auto* temp = _impl_.payload_.capture_;
    _impl_.payload_.capture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_capture(::CapturePiece* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_capture();
    _impl_.payload_.capture_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.capture)
}
inline ::CapturePiece* Command::_internal_mutable_capture() {
  if (payload_case() != kCapture) {
    clear_payload();
    set_has_capture();
    _impl_.payload_.capture_ =
        ::google::protobuf::Message::DefaultConstruct<::CapturePiece>(GetArena());
  }
  return _impl_.payload_.capture_;
}
inline ::CapturePiece* Command::mutable_capture() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::CapturePiece* _msg = _internal_mutable_capture();
  // @@protoc_insertion_point(field_mutable:Command.capture)
  return _msg;
}

// .WhereToMovePiece whereToMovePiece = 5;
inline bool Command::has_wheretomovepiece() const {
  return payload_case() == kWhereToMovePiece;
}
inline bool Command::_internal_has_wheretomovepiece() const {
  return payload_case() == kWhereToMovePiece;
}
inline void Command::set_has_wheretomovepiece() {
  _impl_._oneof_case_[0] = kWhereToMovePiece;
}
inline void Command::clear_wheretomovepiece() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kWhereToMovePiece) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.wheretomovepiece_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.wheretomovepiece_);
    }
    clear_has_payload();
  }
}
inline ::WhereToMovePiece* Command::release_wheretomovepiece() {
  // @@protoc_insertion_point(field_release:Command.whereToMovePiece)
  if (payload_case() == kWhereToMovePiece) {
    clear_has_payload();
    auto* temp = _impl_.payload_.wheretomovepiece_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.wheretomovepiece_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::WhereToMovePiece& Command::_internal_wheretomovepiece() const {
  return payload_case() == kWhereToMovePiece ? *_impl_.payload_.wheretomovepiece_ : reinterpret_cast<::WhereToMovePiece&>(::_WhereToMovePiece_default_instance_);
}
inline const ::WhereToMovePiece& Command::wheretomovepiece() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Command.whereToMovePiece)
  return _internal_wheretomovepiece();
}
inline ::WhereToMovePiece* Command::unsafe_arena_release_wheretomovepiece() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Command.whereToMovePiece)
  if (payload_case() == kWhereToMovePiece) {
    clear_has_payload();
    auto* temp = _impl_.payload_.wheretomovepiece_;
    _impl_.payload_.wheretomovepiece_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_wheretomovepiece(::WhereToMovePiece* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_wheretomovepiece();
    _impl_.payload_.wheretomovepiece_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.whereToMovePiece)
}
inline ::WhereToMovePiece* Command::_internal_mutable_wheretomovepiece() {
  if (payload_case() != kWhereToMovePiece) {
    clear_payload();
    set_has_wheretomovepiece();
    _impl_.payload_.wheretomovepiece_ =
        ::google::protobuf::Message::DefaultConstruct<::WhereToMovePiece>(GetArena());
  }
  return _impl_.payload_.wheretomovepiece_;
}
inline ::WhereToMovePiece* Command::mutable_wheretomovepiece() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::WhereToMovePiece* _msg = _internal_mutable_wheretomovepiece();
  // @@protoc_insertion_point(field_mutable:Command.whereToMovePiece)
  return _msg;
}

// .SetStrategy setStrategy = 6;
inline bool Command::has_setstrategy() const {
  return payload_case() == kSetStrategy;
}
inline bool Command::_internal_has_setstrategy() const {
  return payload_case() == kSetStrategy;
}
inline void Command::set_has_setstrategy() {
  _impl_._oneof_case_[0] = kSetStrategy;
}
inline void Command::clear_setstrategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kSetStrategy) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.setstrategy_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.setstrategy_);
    }
    clear_has_payload();
  }
}
inline ::SetStrategy* Command::release_setstrategy() {
  // @@protoc_insertion_point(field_release:Command.setStrategy)
  if (payload_case() == kSetStrategy) {
    clear_has_payload();
    auto* temp = _impl_.payload_.setstrategy_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.setstrategy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SetStrategy& Command::_internal_setstrategy() const {
  return payload_case() == kSetStrategy ? *_impl_.payload_.setstrategy_ : reinterpret_cast<::SetStrategy&>(::_SetStrategy_default_instance_);
}
inline const ::SetStrategy& Command::setstrategy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Command.setStrategy)
  return _internal_setstrategy();
}
inline ::SetStrategy* Command::unsafe_arena_release_setstrategy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Command.setStrategy)
  if (payload_case() == kSetStrategy) {
    clear_has_payload();
    auto* temp = _impl_.payload_.setstrategy_;
    _impl_.payload_.setstrategy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_setstrategy(::SetStrategy* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_setstrategy();
    _impl_.payload_.setstrategy_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.setStrategy)
}
inline ::SetStrategy* Command::_internal_mutable_setstrategy() {
  if (payload_case() != kSetStrategy) {
    clear_payload();
    set_has_setstrategy();
    _impl_.payload_.setstrategy_ =
        ::google::protobuf::Message::DefaultConstruct<::SetStrategy>(GetArena());
  }
  return _impl_.payload_.setstrategy_;
}
inline ::SetStrategy* Command::mutable_setstrategy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::SetStrategy* _msg = _internal_mutable_setstrategy();
  // @@protoc_insertion_point(field_mutable:Command.setStrategy)
  return _msg;
}

// .GetTime getTime = 7;
inline bool Command::has_gettime() const {
  return payload_case() == kGetTime;
}
inline bool Command::_internal_has_gettime() const {
  return payload_case() == kGetTime;
}
inline void Command::set_has_gettime() {
  _impl_._oneof_case_[0] = kGetTime;
}
inline void Command::clear_gettime() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kGetTime) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.gettime_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.gettime_);
    }
    clear_has_payload();
  }
}
inline ::GetTime* Command::release_gettime() {
  // @@protoc_insertion_point(field_release:Command.getTime)
  if (payload_case() == kGetTime) {
    clear_has_payload();
    auto* temp = _impl_.payload_.gettime_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.gettime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GetTime& Command::_internal_gettime() const {
  return payload_case() == kGetTime ? *_impl_.payload_.gettime_ : reinterpret_cast<::GetTime&>(::_GetTime_default_instance_);
}
inline const ::GetTime& Command::gettime() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Command.getTime)
  return _internal_gettime();
}
inline ::GetTime* Command::unsafe_arena_release_gettime() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Command.getTime)
  if (payload_case() == kGetTime) {
    clear_has_payload();
    auto* temp = _impl_.payload_.gettime_;
    _impl_.payload_.gettime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_gettime(::GetTime* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_gettime();
    _impl_.payload_.gettime_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.getTime)
}
inline ::GetTime* Command::_internal_mutable_gettime() {
  if (payload_case() != kGetTime) {
    clear_payload();
    set_has_gettime();
    _impl_.payload_.gettime_ =
        ::google::protobuf::Message::DefaultConstruct<::GetTime>(GetArena());
  }
  return _impl_.payload_.gettime_;
}
inline ::GetTime* Command::mutable_gettime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::GetTime* _msg = _internal_mutable_gettime();
  // @@protoc_insertion_point(field_mutable:Command.getTime)
  return _msg;
}

// .GetProxyPlayer getproxyPlayer = 8;
inline bool Command::has_getproxyplayer() const {
  return payload_case() == kGetproxyPlayer;
}
inline bool Command::_internal_has_getproxyplayer() const {
  return payload_case() == kGetproxyPlayer;
}
inline void Command::set_has_getproxyplayer() {
  _impl_._oneof_case_[0] = kGetproxyPlayer;
}
inline void Command::clear_getproxyplayer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kGetproxyPlayer) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.getproxyplayer_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.getproxyplayer_);
    }
    clear_has_payload();
  }
}
inline ::GetProxyPlayer* Command::release_getproxyplayer() {
  // @@protoc_insertion_point(field_release:Command.getproxyPlayer)
  if (payload_case() == kGetproxyPlayer) {
    clear_has_payload();
    auto* temp = _impl_.payload_.getproxyplayer_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.getproxyplayer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GetProxyPlayer& Command::_internal_getproxyplayer() const {
  return payload_case() == kGetproxyPlayer ? *_impl_.payload_.getproxyplayer_ : reinterpret_cast<::GetProxyPlayer&>(::_GetProxyPlayer_default_instance_);
}
inline const ::GetProxyPlayer& Command::getproxyplayer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Command.getproxyPlayer)
  return _internal_getproxyplayer();
}
inline ::GetProxyPlayer* Command::unsafe_arena_release_getproxyplayer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Command.getproxyPlayer)
  if (payload_case() == kGetproxyPlayer) {
    clear_has_payload();
    auto* temp = _impl_.payload_.getproxyplayer_;
    _impl_.payload_.getproxyplayer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_getproxyplayer(::GetProxyPlayer* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_getproxyplayer();
    _impl_.payload_.getproxyplayer_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.getproxyPlayer)
}
inline ::GetProxyPlayer* Command::_internal_mutable_getproxyplayer() {
  if (payload_case() != kGetproxyPlayer) {
    clear_payload();
    set_has_getproxyplayer();
    _impl_.payload_.getproxyplayer_ =
        ::google::protobuf::Message::DefaultConstruct<::GetProxyPlayer>(GetArena());
  }
  return _impl_.payload_.getproxyplayer_;
}
inline ::GetProxyPlayer* Command::mutable_getproxyplayer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::GetProxyPlayer* _msg = _internal_mutable_getproxyplayer();
  // @@protoc_insertion_point(field_mutable:Command.getproxyPlayer)
  return _msg;
}

// .UndoAction undoAction = 9;
inline bool Command::has_undoaction() const {
  return payload_case() == kUndoAction;
}
inline bool Command::_internal_has_undoaction() const {
  return payload_case() == kUndoAction;
}
inline void Command::set_has_undoaction() {
  _impl_._oneof_case_[0] = kUndoAction;
}
inline void Command::clear_undoaction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kUndoAction) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.undoaction_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.undoaction_);
    }
    clear_has_payload();
  }
}
inline ::UndoAction* Command::release_undoaction() {
  // @@protoc_insertion_point(field_release:Command.undoAction)
  if (payload_case() == kUndoAction) {
    clear_has_payload();
    auto* temp = _impl_.payload_.undoaction_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.undoaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UndoAction& Command::_internal_undoaction() const {
  return payload_case() == kUndoAction ? *_impl_.payload_.undoaction_ : reinterpret_cast<::UndoAction&>(::_UndoAction_default_instance_);
}
inline const ::UndoAction& Command::undoaction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Command.undoAction)
  return _internal_undoaction();
}
inline ::UndoAction* Command::unsafe_arena_release_undoaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Command.undoAction)
  if (payload_case() == kUndoAction) {
    clear_has_payload();
    auto* temp = _impl_.payload_.undoaction_;
    _impl_.payload_.undoaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_undoaction(::UndoAction* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_undoaction();
    _impl_.payload_.undoaction_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.undoAction)
}
inline ::UndoAction* Command::_internal_mutable_undoaction() {
  if (payload_case() != kUndoAction) {
    clear_payload();
    set_has_undoaction();
    _impl_.payload_.undoaction_ =
        ::google::protobuf::Message::DefaultConstruct<::UndoAction>(GetArena());
  }
  return _impl_.payload_.undoaction_;
}
inline ::UndoAction* Command::mutable_undoaction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UndoAction* _msg = _internal_mutable_undoaction();
  // @@protoc_insertion_point(field_mutable:Command.undoAction)
  return _msg;
}

// .GetState getState = 10;
inline bool Command::has_getstate() const {
  return payload_case() == kGetState;
}
inline bool Command::_internal_has_getstate() const {
  return payload_case() == kGetState;
}
inline void Command::set_has_getstate() {
  _impl_._oneof_case_[0] = kGetState;
}
inline void Command::clear_getstate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kGetState) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.getstate_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.getstate_);
    }
    clear_has_payload();
  }
}
inline ::GetState* Command::release_getstate() {
  // @@protoc_insertion_point(field_release:Command.getState)
  if (payload_case() == kGetState) {
    clear_has_payload();
    auto* temp = _impl_.payload_.getstate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.getstate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GetState& Command::_internal_getstate() const {
  return payload_case() == kGetState ? *_impl_.payload_.getstate_ : reinterpret_cast<::GetState&>(::_GetState_default_instance_);
}
inline const ::GetState& Command::getstate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Command.getState)
  return _internal_getstate();
}
inline ::GetState* Command::unsafe_arena_release_getstate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Command.getState)
  if (payload_case() == kGetState) {
    clear_has_payload();
    auto* temp = _impl_.payload_.getstate_;
    _impl_.payload_.getstate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_getstate(::GetState* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_getstate();
    _impl_.payload_.getstate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.getState)
}
inline ::GetState* Command::_internal_mutable_getstate() {
  if (payload_case() != kGetState) {
    clear_payload();
    set_has_getstate();
    _impl_.payload_.getstate_ =
        ::google::protobuf::Message::DefaultConstruct<::GetState>(GetArena());
  }
  return _impl_.payload_.getstate_;
}
inline ::GetState* Command::mutable_getstate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::GetState* _msg = _internal_mutable_getstate();
  // @@protoc_insertion_point(field_mutable:Command.getState)
  return _msg;
}

// .GetWinner getWinner = 11;
inline bool Command::has_getwinner() const {
  return payload_case() == kGetWinner;
}
inline bool Command::_internal_has_getwinner() const {
  return payload_case() == kGetWinner;
}
inline void Command::set_has_getwinner() {
  _impl_._oneof_case_[0] = kGetWinner;
}
inline void Command::clear_getwinner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kGetWinner) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.getwinner_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.getwinner_);
    }
    clear_has_payload();
  }
}
inline ::GetWinner* Command::release_getwinner() {
  // @@protoc_insertion_point(field_release:Command.getWinner)
  if (payload_case() == kGetWinner) {
    clear_has_payload();
    auto* temp = _impl_.payload_.getwinner_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.getwinner_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GetWinner& Command::_internal_getwinner() const {
  return payload_case() == kGetWinner ? *_impl_.payload_.getwinner_ : reinterpret_cast<::GetWinner&>(::_GetWinner_default_instance_);
}
inline const ::GetWinner& Command::getwinner() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Command.getWinner)
  return _internal_getwinner();
}
inline ::GetWinner* Command::unsafe_arena_release_getwinner() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Command.getWinner)
  if (payload_case() == kGetWinner) {
    clear_has_payload();
    auto* temp = _impl_.payload_.getwinner_;
    _impl_.payload_.getwinner_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_getwinner(::GetWinner* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_getwinner();
    _impl_.payload_.getwinner_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.getWinner)
}
inline ::GetWinner* Command::_internal_mutable_getwinner() {
  if (payload_case() != kGetWinner) {
    clear_payload();
    set_has_getwinner();
    _impl_.payload_.getwinner_ =
        ::google::protobuf::Message::DefaultConstruct<::GetWinner>(GetArena());
  }
  return _impl_.payload_.getwinner_;
}
inline ::GetWinner* Command::mutable_getwinner() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::GetWinner* _msg = _internal_mutable_getwinner();
  // @@protoc_insertion_point(field_mutable:Command.getWinner)
  return _msg;
}

// .GetError getError = 12;
inline bool Command::has_geterror() const {
  return payload_case() == kGetError;
}
inline bool Command::_internal_has_geterror() const {
  return payload_case() == kGetError;
}
inline void Command::set_has_geterror() {
  _impl_._oneof_case_[0] = kGetError;
}
inline void Command::clear_geterror() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kGetError) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.geterror_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.geterror_);
    }
    clear_has_payload();
  }
}
inline ::GetError* Command::release_geterror() {
  // @@protoc_insertion_point(field_release:Command.getError)
  if (payload_case() == kGetError) {
    clear_has_payload();
    auto* temp = _impl_.payload_.geterror_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.geterror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GetError& Command::_internal_geterror() const {
  return payload_case() == kGetError ? *_impl_.payload_.geterror_ : reinterpret_cast<::GetError&>(::_GetError_default_instance_);
}
inline const ::GetError& Command::geterror() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Command.getError)
  return _internal_geterror();
}
inline ::GetError* Command::unsafe_arena_release_geterror() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Command.getError)
  if (payload_case() == kGetError) {
    clear_has_payload();
    auto* temp = _impl_.payload_.geterror_;
    _impl_.payload_.geterror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_geterror(::GetError* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_geterror();
    _impl_.payload_.geterror_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Command.getError)
}
inline ::GetError* Command::_internal_mutable_geterror() {
  if (payload_case() != kGetError) {
    clear_payload();
    set_has_geterror();
    _impl_.payload_.geterror_ =
        ::google::protobuf::Message::DefaultConstruct<::GetError>(GetArena());
  }
  return _impl_.payload_.geterror_;
}
inline ::GetError* Command::mutable_geterror() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::GetError* _msg = _internal_mutable_geterror();
  // @@protoc_insertion_point(field_mutable:Command.getError)
  return _msg;
}

inline bool Command::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Command::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Command::PayloadCase Command::payload_case() const {
  return Command::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetProxyPlayer

// int32 player = 1;
inline void GetProxyPlayer::clear_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_ = 0;
}
inline ::int32_t GetProxyPlayer::player() const {
  // @@protoc_insertion_point(field_get:GetProxyPlayer.player)
  return _internal_player();
}
inline void GetProxyPlayer::set_player(::int32_t value) {
  _internal_set_player(value);
  // @@protoc_insertion_point(field_set:GetProxyPlayer.player)
}
inline ::int32_t GetProxyPlayer::_internal_player() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_;
}
inline void GetProxyPlayer::_internal_set_player(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_ = value;
}

// -------------------------------------------------------------------

// GetError

// int32 error = 1;
inline void GetError::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = 0;
}
inline ::int32_t GetError::error() const {
  // @@protoc_insertion_point(field_get:GetError.error)
  return _internal_error();
}
inline void GetError::set_error(::int32_t value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:GetError.error)
}
inline ::int32_t GetError::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_;
}
inline void GetError::_internal_set_error(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = value;
}

// -------------------------------------------------------------------

// MovePiece

// int32 from_x = 1;
inline void MovePiece::clear_from_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_x_ = 0;
}
inline ::int32_t MovePiece::from_x() const {
  // @@protoc_insertion_point(field_get:MovePiece.from_x)
  return _internal_from_x();
}
inline void MovePiece::set_from_x(::int32_t value) {
  _internal_set_from_x(value);
  // @@protoc_insertion_point(field_set:MovePiece.from_x)
}
inline ::int32_t MovePiece::_internal_from_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_x_;
}
inline void MovePiece::_internal_set_from_x(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_x_ = value;
}

// int32 from_y = 2;
inline void MovePiece::clear_from_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_y_ = 0;
}
inline ::int32_t MovePiece::from_y() const {
  // @@protoc_insertion_point(field_get:MovePiece.from_y)
  return _internal_from_y();
}
inline void MovePiece::set_from_y(::int32_t value) {
  _internal_set_from_y(value);
  // @@protoc_insertion_point(field_set:MovePiece.from_y)
}
inline ::int32_t MovePiece::_internal_from_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_y_;
}
inline void MovePiece::_internal_set_from_y(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_y_ = value;
}

// int32 to_x = 3;
inline void MovePiece::clear_to_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_x_ = 0;
}
inline ::int32_t MovePiece::to_x() const {
  // @@protoc_insertion_point(field_get:MovePiece.to_x)
  return _internal_to_x();
}
inline void MovePiece::set_to_x(::int32_t value) {
  _internal_set_to_x(value);
  // @@protoc_insertion_point(field_set:MovePiece.to_x)
}
inline ::int32_t MovePiece::_internal_to_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_x_;
}
inline void MovePiece::_internal_set_to_x(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_x_ = value;
}

// int32 to_y = 4;
inline void MovePiece::clear_to_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_y_ = 0;
}
inline ::int32_t MovePiece::to_y() const {
  // @@protoc_insertion_point(field_get:MovePiece.to_y)
  return _internal_to_y();
}
inline void MovePiece::set_to_y(::int32_t value) {
  _internal_set_to_y(value);
  // @@protoc_insertion_point(field_set:MovePiece.to_y)
}
inline ::int32_t MovePiece::_internal_to_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_y_;
}
inline void MovePiece::_internal_set_to_y(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_y_ = value;
}

// int32 player = 5;
inline void MovePiece::clear_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_ = 0;
}
inline ::int32_t MovePiece::player() const {
  // @@protoc_insertion_point(field_get:MovePiece.player)
  return _internal_player();
}
inline void MovePiece::set_player(::int32_t value) {
  _internal_set_player(value);
  // @@protoc_insertion_point(field_set:MovePiece.player)
}
inline ::int32_t MovePiece::_internal_player() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_;
}
inline void MovePiece::_internal_set_player(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_ = value;
}

// -------------------------------------------------------------------

// GetState

// int32 state = 1;
inline void GetState::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = 0;
}
inline ::int32_t GetState::state() const {
  // @@protoc_insertion_point(field_get:GetState.state)
  return _internal_state();
}
inline void GetState::set_state(::int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:GetState.state)
}
inline ::int32_t GetState::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.state_;
}
inline void GetState::_internal_set_state(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = value;
}

// int32 player = 2;
inline void GetState::clear_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_ = 0;
}
inline ::int32_t GetState::player() const {
  // @@protoc_insertion_point(field_get:GetState.player)
  return _internal_player();
}
inline void GetState::set_player(::int32_t value) {
  _internal_set_player(value);
  // @@protoc_insertion_point(field_set:GetState.player)
}
inline ::int32_t GetState::_internal_player() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_;
}
inline void GetState::_internal_set_player(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_ = value;
}

// -------------------------------------------------------------------

// GetWinner

// int32 state = 1;
inline void GetWinner::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = 0;
}
inline ::int32_t GetWinner::state() const {
  // @@protoc_insertion_point(field_get:GetWinner.state)
  return _internal_state();
}
inline void GetWinner::set_state(::int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:GetWinner.state)
}
inline ::int32_t GetWinner::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.state_;
}
inline void GetWinner::_internal_set_state(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// PlacePiece

// int32 x = 1;
inline void PlacePiece::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline ::int32_t PlacePiece::x() const {
  // @@protoc_insertion_point(field_get:PlacePiece.x)
  return _internal_x();
}
inline void PlacePiece::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:PlacePiece.x)
}
inline ::int32_t PlacePiece::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void PlacePiece::_internal_set_x(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// int32 y = 2;
inline void PlacePiece::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline ::int32_t PlacePiece::y() const {
  // @@protoc_insertion_point(field_get:PlacePiece.y)
  return _internal_y();
}
inline void PlacePiece::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:PlacePiece.y)
}
inline ::int32_t PlacePiece::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void PlacePiece::_internal_set_y(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// int32 player = 3;
inline void PlacePiece::clear_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_ = 0;
}
inline ::int32_t PlacePiece::player() const {
  // @@protoc_insertion_point(field_get:PlacePiece.player)
  return _internal_player();
}
inline void PlacePiece::set_player(::int32_t value) {
  _internal_set_player(value);
  // @@protoc_insertion_point(field_set:PlacePiece.player)
}
inline ::int32_t PlacePiece::_internal_player() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_;
}
inline void PlacePiece::_internal_set_player(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_ = value;
}

// -------------------------------------------------------------------

// CapturePiece

// int32 x = 1;
inline void CapturePiece::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline ::int32_t CapturePiece::x() const {
  // @@protoc_insertion_point(field_get:CapturePiece.x)
  return _internal_x();
}
inline void CapturePiece::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:CapturePiece.x)
}
inline ::int32_t CapturePiece::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void CapturePiece::_internal_set_x(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// int32 y = 2;
inline void CapturePiece::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline ::int32_t CapturePiece::y() const {
  // @@protoc_insertion_point(field_get:CapturePiece.y)
  return _internal_y();
}
inline void CapturePiece::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:CapturePiece.y)
}
inline ::int32_t CapturePiece::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void CapturePiece::_internal_set_y(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// WhereToMovePiece

// int32 x = 1;
inline void WhereToMovePiece::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline ::int32_t WhereToMovePiece::x() const {
  // @@protoc_insertion_point(field_get:WhereToMovePiece.x)
  return _internal_x();
}
inline void WhereToMovePiece::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:WhereToMovePiece.x)
}
inline ::int32_t WhereToMovePiece::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void WhereToMovePiece::_internal_set_x(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// int32 y = 2;
inline void WhereToMovePiece::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline ::int32_t WhereToMovePiece::y() const {
  // @@protoc_insertion_point(field_get:WhereToMovePiece.y)
  return _internal_y();
}
inline void WhereToMovePiece::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:WhereToMovePiece.y)
}
inline ::int32_t WhereToMovePiece::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void WhereToMovePiece::_internal_set_y(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// repeated .IntPair pairs = 3;
inline int WhereToMovePiece::_internal_pairs_size() const {
  return _internal_pairs().size();
}
inline int WhereToMovePiece::pairs_size() const {
  return _internal_pairs_size();
}
inline void WhereToMovePiece::clear_pairs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pairs_.Clear();
}
inline ::IntPair* WhereToMovePiece::mutable_pairs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:WhereToMovePiece.pairs)
  return _internal_mutable_pairs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::IntPair>* WhereToMovePiece::mutable_pairs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:WhereToMovePiece.pairs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_pairs();
}
inline const ::IntPair& WhereToMovePiece::pairs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:WhereToMovePiece.pairs)
  return _internal_pairs().Get(index);
}
inline ::IntPair* WhereToMovePiece::add_pairs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::IntPair* _add = _internal_mutable_pairs()->Add();
  // @@protoc_insertion_point(field_add:WhereToMovePiece.pairs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::IntPair>& WhereToMovePiece::pairs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:WhereToMovePiece.pairs)
  return _internal_pairs();
}
inline const ::google::protobuf::RepeatedPtrField<::IntPair>&
WhereToMovePiece::_internal_pairs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pairs_;
}
inline ::google::protobuf::RepeatedPtrField<::IntPair>*
WhereToMovePiece::_internal_mutable_pairs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.pairs_;
}

// -------------------------------------------------------------------

// SetStrategy

// int32 x = 1;
inline void SetStrategy::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline ::int32_t SetStrategy::x() const {
  // @@protoc_insertion_point(field_get:SetStrategy.x)
  return _internal_x();
}
inline void SetStrategy::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:SetStrategy.x)
}
inline ::int32_t SetStrategy::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void SetStrategy::_internal_set_x(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// -------------------------------------------------------------------

// GetTime

// int32 timePlayer1 = 1;
inline void GetTime::clear_timeplayer1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeplayer1_ = 0;
}
inline ::int32_t GetTime::timeplayer1() const {
  // @@protoc_insertion_point(field_get:GetTime.timePlayer1)
  return _internal_timeplayer1();
}
inline void GetTime::set_timeplayer1(::int32_t value) {
  _internal_set_timeplayer1(value);
  // @@protoc_insertion_point(field_set:GetTime.timePlayer1)
}
inline ::int32_t GetTime::_internal_timeplayer1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeplayer1_;
}
inline void GetTime::_internal_set_timeplayer1(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeplayer1_ = value;
}

// int32 timePlayer2 = 2;
inline void GetTime::clear_timeplayer2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeplayer2_ = 0;
}
inline ::int32_t GetTime::timeplayer2() const {
  // @@protoc_insertion_point(field_get:GetTime.timePlayer2)
  return _internal_timeplayer2();
}
inline void GetTime::set_timeplayer2(::int32_t value) {
  _internal_set_timeplayer2(value);
  // @@protoc_insertion_point(field_set:GetTime.timePlayer2)
}
inline ::int32_t GetTime::_internal_timeplayer2() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeplayer2_;
}
inline void GetTime::_internal_set_timeplayer2(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeplayer2_ = value;
}

// int32 timeAction = 3;
inline void GetTime::clear_timeaction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeaction_ = 0;
}
inline ::int32_t GetTime::timeaction() const {
  // @@protoc_insertion_point(field_get:GetTime.timeAction)
  return _internal_timeaction();
}
inline void GetTime::set_timeaction(::int32_t value) {
  _internal_set_timeaction(value);
  // @@protoc_insertion_point(field_set:GetTime.timeAction)
}
inline ::int32_t GetTime::_internal_timeaction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeaction_;
}
inline void GetTime::_internal_set_timeaction(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeaction_ = value;
}

// -------------------------------------------------------------------

// IntPair

// int32 first = 1;
inline void IntPair::clear_first() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.first_ = 0;
}
inline ::int32_t IntPair::first() const {
  // @@protoc_insertion_point(field_get:IntPair.first)
  return _internal_first();
}
inline void IntPair::set_first(::int32_t value) {
  _internal_set_first(value);
  // @@protoc_insertion_point(field_set:IntPair.first)
}
inline ::int32_t IntPair::_internal_first() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.first_;
}
inline void IntPair::_internal_set_first(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.first_ = value;
}

// int32 second = 2;
inline void IntPair::clear_second() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.second_ = 0;
}
inline ::int32_t IntPair::second() const {
  // @@protoc_insertion_point(field_get:IntPair.second)
  return _internal_second();
}
inline void IntPair::set_second(::int32_t value) {
  _internal_set_second(value);
  // @@protoc_insertion_point(field_set:IntPair.second)
}
inline ::int32_t IntPair::_internal_second() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.second_;
}
inline void IntPair::_internal_set_second(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.second_ = value;
}

// -------------------------------------------------------------------

// UndoAction

// int32 state = 1;
inline void UndoAction::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = 0;
}
inline ::int32_t UndoAction::state() const {
  // @@protoc_insertion_point(field_get:UndoAction.state)
  return _internal_state();
}
inline void UndoAction::set_state(::int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:UndoAction.state)
}
inline ::int32_t UndoAction::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.state_;
}
inline void UndoAction::_internal_set_state(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = value;
}

// int32 player = 2;
inline void UndoAction::clear_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_ = 0;
}
inline ::int32_t UndoAction::player() const {
  // @@protoc_insertion_point(field_get:UndoAction.player)
  return _internal_player();
}
inline void UndoAction::set_player(::int32_t value) {
  _internal_set_player(value);
  // @@protoc_insertion_point(field_set:UndoAction.player)
}
inline ::int32_t UndoAction::_internal_player() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_;
}
inline void UndoAction::_internal_set_player(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_ = value;
}

// repeated .IntPair position = 3;
inline int UndoAction::_internal_position_size() const {
  return _internal_position().size();
}
inline int UndoAction::position_size() const {
  return _internal_position_size();
}
inline void UndoAction::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_.Clear();
}
inline ::IntPair* UndoAction::mutable_position(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:UndoAction.position)
  return _internal_mutable_position()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::IntPair>* UndoAction::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:UndoAction.position)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_position();
}
inline const ::IntPair& UndoAction::position(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UndoAction.position)
  return _internal_position().Get(index);
}
inline ::IntPair* UndoAction::add_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::IntPair* _add = _internal_mutable_position()->Add();
  // @@protoc_insertion_point(field_add:UndoAction.position)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::IntPair>& UndoAction::position() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:UndoAction.position)
  return _internal_position();
}
inline const ::google::protobuf::RepeatedPtrField<::IntPair>&
UndoAction::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.position_;
}
inline ::google::protobuf::RepeatedPtrField<::IntPair>*
UndoAction::_internal_mutable_position() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.position_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::Ecommand> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::Ecommand>() {
  return ::Ecommand_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_protocolClient_2eproto_2epb_2eh
